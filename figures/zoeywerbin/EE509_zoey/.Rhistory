n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta"),
n.iter = 20000)
jags.burn <- window(var.out,start=1000)  ## remove burn-in
gelman.diag(jags.burn) # very close to 1 - good
effectiveSize(jags.burn) # above 2k - good enough
out <- as.matrix(jags.burn)
params <- summary(jags.burn)
dic.pois <- dic.samples(j.model, 5000)
print(dic.pois) # check DIC
print(params)
plot(var.out)
plot(y~TDR)
b1 <- params$statistics[1,1]
b2 <- params$statistics[2,1]
## credible and prediction intervals
nsamp <- 5000
samp <- sample.int(nrow(var.mat),nsamp)
npred <- length(xpred)				##      make predictions for
ypred <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for predictive interval
ycred <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for credible interval
for(g in seq_len(nsamp)){
theta = var.mat[samp[g],]
ycred[g,] <- exp(theta["beta[1]"] + theta["beta[2]"]*xpred)
ypred[g,] <- rpois(npred,ycred[g,])
}
ci <- apply(ycred,2,quantile,c(0.025,0.5,0.975))  ## credible interval and median
pi <- apply(ypred,2,quantile,c(0.025,0.975))		## prediction interval
plot(TDR,y,cex=0.5,xlim=c(0,1),ylim=c(0,50))
lines(xpred,ci[1,],col=3,lty=2)	## lower CI
lines(xpred,ci[2,],col=3,lwd=3)	## median
lines(xpred,ci[3,],col=3,lty=2)	## upper CI
lines(xpred,pi[1,],col=4,lty=2)	## lower PI
lines(xpred,pi[2,],col=4,lty=2)	## upper PI
abline(b1,b2)				## true model
b1 <- params$statistics[1,1]
b2 <- params$statistics[2,1]
## credible and prediction intervals
nsamp <- 5000
samp <- sample.int(nrow(out),nsamp)
npred <- length(xpred)				##      make predictions for
ypred <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for predictive interval
ycred <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for credible interval
for(g in seq_len(nsamp)){
theta = out[samp[g],]
ycred[g,] <- exp(theta["beta[1]"] + theta["beta[2]"]*xpred)
ypred[g,] <- rpois(npred,ycred[g,])
}
ci <- apply(ycred,2,quantile,c(0.025,0.5,0.975))  ## credible interval and median
pi <- apply(ypred,2,quantile,c(0.025,0.975))		## prediction interval
ypred <- exp(mean(b1) + mean(b2)*xpred) ## mean model predictions
plot(TDR,y,cex=0.5,xlim=c(0,1),ylim=c(0,50))
lines(xpred,ci[1,],col=3,lty=2)	## lower CI
lines(xpred,ci[2,],col=3,lwd=3)	## median
lines(xpred,ci[3,],col=3,lty=2)	## upper CI
lines(xpred,pi[1,],col=4,lty=2)	## lower PI
lines(xpred,pi[2,],col=4,lty=2)	## upper PI
lines(xpred, ypred)
coef(PR1)
pois_regression_missing <- "
model{
beta ~ dmnorm(b0,Vb)  	## prior regression params
TDR[12] ~ dunif(0,1)    ## prior on missing TDR value
for(i in 1:n){
log(mu[i]) <- beta[1]+beta[2]*TDR[i]     ## process model
y[i]  ~ dpois(mu[i])		                 ## data model
}
}
"
TDR.copy <- TDR
TDR.copy[12] <- NA
# create data object
data <- list(TDR = TDR.copy, y = y, n = n,
b0 = as.vector(c(0,0)),    ## regression beta means
Vb = solve(diag(10000,2))) ## regression beta precisions
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5))
}
j.model   <- jags.model(file = textConnection(pois_regression_missing),
data = data,
inits = inits,
n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta", "TDR[12]"),
n.iter = 2000)
var.mat      <- as.matrix(var.out)
params <- summary(var.out)
print(params)
# view density plots for beta and missing TDR value
plot(var.out)
max(TDR)
pois_regression_missing <- "
model{
beta ~ dmnorm(b0,Vb)  	## prior regression params
TDR[12] ~ dunif(0,.6)    ## prior on missing TDR value
for(i in 1:n){
log(mu[i]) <- beta[1]+beta[2]*TDR[i]     ## process model
y[i]  ~ dpois(mu[i])		                 ## data model
}
}
"
TDR.copy <- TDR
TDR.copy[12] <- NA
# create data object
data <- list(TDR = TDR.copy, y = y, n = n,
b0 = as.vector(c(0,0)),    ## regression beta means
Vb = solve(diag(10000,2))) ## regression beta precisions
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5))
}
j.model   <- jags.model(file = textConnection(pois_regression_missing),
data = data,
inits = inits,
n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta", "TDR[12]"),
n.iter = 2000)
var.mat      <- as.matrix(var.out)
params <- summary(var.out)
print(params)
# view density plots for beta and missing TDR value
plot(var.out)
pois_regression_missing <- "
model{
beta ~ dmnorm(b0,Vb)  	## prior regression params
TDR[12] ~ dunif(0,.6)    ## prior on missing TDR value
for(i in 1:n){
log(mu[i]) <- beta[1]+beta[2]*TDR[i]     ## process model
y[i]  ~ dpois(mu[i])		                 ## data model
}
}
"
TDR.copy <- TDR
TDR.copy[12] <- NA
# create data object
data <- list(TDR = TDR.copy, y = y, n = n,
b0 = as.vector(c(0,0)),    ## regression beta means
Vb = solve(diag(10000,2))) ## regression beta precisions
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5))
}
j.model   <- jags.model(file = textConnection(pois_regression_missing),
data = data,
inits = inits,
n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta", "TDR[12]"),
n.iter = 10000)
params <- summary(var.out)
print(params)
# view density plots for beta and missing TDR value
plot(var.out)
print(TDR[12])
# view density plots for beta and missing TDR value
plot(var.out)
TDR[12]
hist(TDR)
TDR.copy <- TDR
TDR.copy[7] <- NA
TDR[7]
TDR[8]
TDR.copy <- TDR
TDR.copy[8] <- NA
TDR.copy
# create data object
data <- list(TDR = TDR.copy, y = y, n = n,
b0 = as.vector(c(0,0)),    ## regression beta means
Vb = solve(diag(10000,2))) ## regression beta precisions
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5))
}
j.model   <- jags.model(file = textConnection(pois_regression_missing),
data = data,
inits = inits,
n.chains = nchain)
pois_regression_missing <- "
j.model   <- jags.model(file = textConnection(pois_regression_missing),
data = data,
inits = inits,
n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta", "TDR[8]"),
var.out   <- coda.samples (model = j.model,
variable.names = c("beta", "TDR[8]"),
n.iter = 10000)
params <- summary(var.out)
print(params)
# view density plots for beta and missing TDR value
plot(var.out)
TDR[8]
TDR.copy <- TDR
TDR.copy[8] <- NA
# create data object
data <- list(TDR = TDR.copy, y = y, n = n,
b0 = as.vector(c(0,0)),    ## regression beta means
Vb = solve(diag(10000,2))) ## regression beta precisions
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5))
}
j.model   <- jags.model(file = textConnection(pois_regression_missing),
data = data,
inits = inits,
n.chains = nchain)
pois_regression_missing <- "
pois_regression_missing <- "
model{
pois_regression_missing <- "
pois_regression_missing <- "
model{
pois_regression_missing <- "
model{
beta ~ dmnorm(b0,Vb)  	## prior regression params
pois_regression_missing <- "
model{
pois_regression_missing <- "
model{
beta ~ dmnorm(b0,Vb)  	## prior regression params
TDR[8] ~ dunif(0,.6)    ## prior on missing TDR value
for(i in 1:n){
log(mu[i]) <- beta[1]+beta[2]*TDR[i]     ## process model
y[i]  ~ dpois(mu[i])		                 ## data model
}
}
"
TDR.copy <- TDR
TDR.copy[8] <- NA
# create data object
data <- list(TDR = TDR.copy, y = y, n = n,
b0 = as.vector(c(0,0)),    ## regression beta means
Vb = solve(diag(10000,2))) ## regression beta precisions
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5))
}
j.model   <- jags.model(file = textConnection(pois_regression_missing),
data = data,
inits = inits,
n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta", "TDR[8]"),
n.iter = 10000)
params <- summary(var.out)
print(params)
# view density plots for beta and missing TDR value
plot(var.out)
TDR[8]
mean(TDR)
mean(runif(100, 0,.6))
PoisRegPlusCalib = "
model {
### TDR calibration curve
for(i in 1:2) { alpha[i] ~ dlnorm(0,0.1)}   ## calibration priors
sigma ~ dgamma(0.1,0.1)
for(i in 1:10){
ESMc[i] <- alpha[1] + alpha[2]*TDRc[i]   ## expected soil moisture, calibration process model
SMc[i] ~ dnorm(ESMc[i],sigma)  	         ## calibration data model
}
## Seedling Density vs Soil Moisture
for(i in 1:2) { beta[i] ~ dlnorm(0,0.1)}   ## Poisson regression priors
for(i in 1:n){
ESM[i] <-  alpha[1] + alpha[2]*TDR[i]     ## Errors in Variables – process model
SM[i] ~ dnorm(ESM[i],sigma)               ## Errors in Variables – data model
log(mu[i]) <- beta[1]+beta[2]*SM[i]       ## Poisson Regression – process model
y[i] ~ dpois(mu[i])                       ## Poisson Regression – data model
}
}
"
# create data object
data <- list(TDR = TDR, y = y, n = n,
TDRc = TDRc, SMc = SMc)
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5), alpha = rnorm(2,0,5))
}
f1 = lm(SMc ~ TDRc)
alpha = coef(f1)
inits <- list(alpha=alpha,
SM=alpha[1] + alpha[2]*TDR,
sigma=1/(summary(f1)$sigma^2),
beta = rlnorm(2,0,1))
j.model   <- jags.model(file = textConnection(PoisRegPlusCalib),
data = data,
inits = inits,
n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta", "alpha","sigma"),
n.iter = 100000, thin = 5)
jags.burn <- window(var.out,start=10000)  ## remove burn-in
out <- as.matrix(jags.burn)
jags.model
pois_regression <- "
model{
beta ~ dmnorm(b0,Vb)  	## prior regression params
for(i in 1:n){
log(mu[i]) <- beta[1]+beta[2]*TDR[i]     ## process model
y[i]  ~ dpois(mu[i])		                 ## data model
}
}
"
# create data object
data <- list(TDR = TDR, y = y, n = n,
b0 = as.vector(c(0,0)),    ## regression beta means
Vb = solve(diag(10000,2))) ## regression beta precisions
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5))
}
j.model   <- jags.model(file = textConnection(pois_regression),
data = data,
inits = inits,
n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta"),
n.iter = 20000)
library(rjags)
load("data/Lab9.RData")
PR1 = glm(y ~ TDR, family=poisson(link="log"))
PR1
ic   <- c(0,0) ## initial guess
LnL  <- function(beta){  ## define likelihood
-sum(dpois(y,exp(beta[1] + beta[2]*TDR),log=TRUE))
}
test <- LnL(ic) ## verify likelihood function works
PR2  <- nlm(LnL,ic) ## maximize the likelihood
PR2
xpred <- seq(-0.1, .7, by = .05)  	## sequence of x values we're going to use for prediction
ypred <- exp(coef(PR1)[1] + coef(PR1)[2]*xpred)
plot(y~TDR); lines(xpred, ypred)
fit <- lm(TDRc ~ SMc)
plot(TDRc ~ SMc)
abline(fit)
print(summary(fit))
pois_regression <- "
model{
beta ~ dmnorm(b0,Vb)  	## prior regression params
for(i in 1:n){
log(mu[i]) <- beta[1]+beta[2]*TDR[i]     ## process model
y[i]  ~ dpois(mu[i])		                 ## data model
}
}
"
# create data object
data <- list(TDR = TDR, y = y, n = n,
b0 = as.vector(c(0,0)),    ## regression beta means
Vb = solve(diag(10000,2))) ## regression beta precisions
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5))
}
j.model   <- jags.model(file = textConnection(pois_regression),
data = data,
inits = inits,
n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta"),
n.iter = 20000)
jags.burn <- window(var.out,start=1000)  ## remove burn-in
gelman.diag(jags.burn) # very close to 1 - good
effectiveSize(jags.burn) # above 2k - good enough
out <- as.matrix(jags.burn)
params <- summary(jags.burn)
dic.pois <- dic.samples(j.model, 5000)
print(dic.pois) # check DIC
print(params)
b1 <- params$statistics[1,1]
b2 <- params$statistics[2,1]
## credible and prediction intervals
nsamp <- 5000
samp <- sample.int(nrow(out),nsamp)
npred <- length(xpred)				##      make predictions for
ypred <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for predictive interval
ycred <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for credible interval
for(g in seq_len(nsamp)){
theta = out[samp[g],]
ycred[g,] <- exp(theta["beta[1]"] + theta["beta[2]"]*xpred)
ypred[g,] <- rpois(npred,ycred[g,])
}
ci <- apply(ycred,2,quantile,c(0.025,0.5,0.975))  ## credible interval and median
pi <- apply(ypred,2,quantile,c(0.025,0.975))		## prediction interval
ypred <- exp(mean(b1) + mean(b2)*xpred) ## mean model predictions
plot(TDR,y,cex=0.5,xlim=c(0,1),ylim=c(0,50))
lines(xpred,ci[1,],col=3,lty=2)	## lower CI
lines(xpred,ci[2,],col=3,lwd=3)	## median
lines(xpred,ci[3,],col=3,lty=2)	## upper CI
lines(xpred,pi[1,],col=4,lty=2)	## lower PI
lines(xpred,pi[2,],col=4,lty=2)	## upper PI
lines(xpred, ypred)
pois_regression_missing <- "
model{
beta ~ dmnorm(b0,Vb)  	## prior regression params
TDR[8] ~ dunif(0,.6)    ## prior on missing TDR value
for(i in 1:n){
log(mu[i]) <- beta[1]+beta[2]*TDR[i]     ## process model
y[i]  ~ dpois(mu[i])		                 ## data model
}
}
"
TDR.copy <- TDR
TDR.copy[8] <- NA
# create data object
data <- list(TDR = TDR.copy, y = y, n = n,
b0 = as.vector(c(0,0)),    ## regression beta means
Vb = solve(diag(10000,2))) ## regression beta precisions
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5))
}
j.model   <- jags.model(file = textConnection(pois_regression_missing),
data = data,
inits = inits,
n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta", "TDR[8]"),
n.iter = 10000)
params <- summary(var.out)
print(params)
# view density plots for beta and missing TDR value
plot(var.out)
TDR[8]
PoisRegPlusCalib = "
model {
### TDR calibration curve
for(i in 1:2) { alpha[i] ~ dlnorm(0,0.1)}   ## calibration priors
sigma ~ dgamma(0.1,0.1)
for(i in 1:10){
ESMc[i] <- alpha[1] + alpha[2]*TDRc[i]   ## expected soil moisture, calibration process model
SMc[i] ~ dnorm(ESMc[i],sigma)  	         ## calibration data model
}
## Seedling Density vs Soil Moisture
for(i in 1:2) { beta[i] ~ dlnorm(0,0.1)}   ## Poisson regression priors
for(i in 1:n){
ESM[i] <-  alpha[1] + alpha[2]*TDR[i]     ## Errors in Variables – process model
SM[i] ~ dnorm(ESM[i],sigma)               ## Errors in Variables – data model
log(mu[i]) <- beta[1]+beta[2]*SM[i]       ## Poisson Regression – process model
y[i] ~ dpois(mu[i])                       ## Poisson Regression – data model
}
}
"
# create data object
data <- list(TDR = TDR, y = y, n = n,
TDRc = TDRc, SMc = SMc)
## initial conditions
inits <- list()
for(i in 1:3){
inits[[i]] <- list(beta = rnorm(2,0,5), alpha = rnorm(2,0,5))
}
f1 = lm(SMc ~ TDRc)
alpha = coef(f1)
inits <- list(alpha=alpha,
SM=alpha[1] + alpha[2]*TDR,
sigma=1/(summary(f1)$sigma^2),
beta = rlnorm(2,0,1))
j.model   <- jags.model(file = textConnection(PoisRegPlusCalib),
data = data,
inits = inits,
n.chains = nchain)
var.out   <- coda.samples (model = j.model,
variable.names = c("beta", "alpha","sigma"),
n.iter = 100000, thin = 5)
jags.burn <- window(var.out,start=10000)  ## remove burn-in
out <- as.matrix(jags.burn)
gelman.diag(jags.burn) # converged!
effectiveSize(jags.burn)
plot(jags.burn)
params <- summary(jags.burn)
b1 <- params$statistics[grep("beta[1]", rownames(params$statistics), fixed=TRUE),1]
b2 <- params$statistics[grep("beta[2]", rownames(params$statistics), fixed=TRUE),1]
a1 <- params$statistics[grep("alpha[1]", rownames(params$statistics), fixed=TRUE),1]
a2 <- params$statistics[grep("alpha[2]", rownames(params$statistics), fixed=TRUE),1]
sigma <- params$statistics[grep("sigma", rownames(params$statistics), fixed=TRUE),1]
## credible and prediction intervals
nsamp <- 5000
samp <- sample.int(nrow(out),nsamp)
xpred <- seq(0, .7, by = .05)  					## sequence of x values we're going to
npred <- length(xpred)				##      make predictions for
ypred <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for predictive interval
ycred <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for credible interval
ESM <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for credible interval
SM <- matrix(0.0,nrow=nsamp,ncol=npred)	## storage for credible interval
for(g in seq_len(nsamp)){
theta = out[samp[g],]
sd <- sqrt(1/theta["sigma"])
ESM[g,] <- theta["alpha[1]"] + theta["alpha[2]"]*xpred
SM[g,] <- rnorm(npred, ESM[g,], sd)
ycred[g,] <- exp(theta["beta[1]"] + theta["beta[2]"]*SM[g,])
ypred[g,] <- rpois(npred,ycred[g,])
}
ci <- apply(ycred,2,quantile,c(0.025,0.5,0.975))  ## credible interval and median
pi <- apply(ypred,2,quantile,c(0.025,0.975))		## prediction interval
plot(TDR,y,cex=0.5,xlim=c(0,1),ylim=c(0,50))
lines(xpred,ci[1,],col=3,lty=2)	## lower CI
lines(xpred,ci[2,],col=3,lwd=3)	## median
lines(xpred,ci[3,],col=3,lty=2)	## upper CI
lines(xpred,pi[1,],col=4,lty=2)	## lower PI
lines(xpred,pi[2,],col=4,lty=2)	## upper PI
nchain
