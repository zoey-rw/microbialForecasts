---
title: "Werbin_Results_Exercise_02"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Simulating the discrete-time logistic
-------------------------------------

#Define parameters
```{r, echo=FALSE}
#devtools::install_github("EcoForecast/ecoforecastR")
r = 2.5         ## intrinsic growth rate
K = 10        ## carrying capacity      
n0 = .1       ## initial population size
NT = 30       ## number of time steps to simulate
time = 1:NT
```
### Problem 1

Plot the logistic growth model at r = 1.95, 2.05, 2.5, and 2.8. Describe the trajectory observed in each case.

Iterative simulation:
```{r}
n = rep(n0,NT)    ## vector to store results
rvals <- c(1.95, 2.05, 2.5, 2.8)
for (i in 1:length(rvals)){
  r <- rvals[i]
  for(t in 2:NT){
    n[t] = n[t-1] + r*n[t-1]*(1-n[t-1]/K)
  }
  plot(time,n,ylim=c(0,12),lwd=3,type='l',
       bty='l',cex.lab=1.5,
       xlab="Time",ylab="Population Size",
       main = paste("Logistic growth model at r = ",r))
}
```

Trajectory descriptions:
r = 1.95: Population growth is exponential for about 6 years, after which point oscillations occur. These oscillations occur every ~2 years and population size ranges between 9 and 11, but over time population size values become closer and closer to a value of 10.
r = 2.05: Population grown is exponential for about 6 years, after which point oscillations occur. These oscillations occur every ~2 years and population size ranges between 8 and 11, and remain in this range over time.
r = 2.5: Population grown is exponential for about 5 years, after which oscillations occur. These oscillations start out with values close to K, but get farther from K over time. Values range from 5 to 12.
r = 2.8: Population grown is exponential for about 6 years, after which oscillations occur. These oscillations have values ranging from 3 to 12. With a growth rate this large, the divergence from K is much more drastic than in the previous models.

### Problem 2

Choose another probability distribution and generate graphs of the probability density function, the cumulative distribution function, the quantile function, and a histogram of samples from that distribution.

```{r}

# probability distribution function
x = seq(0,1,by=0.01)
plot(x,dbeta(x, 10, 15),type='l')  		## that’s a lowercase “L” for “line”
abline(v=(10/(10+15)))						# mean of beta distribution is a/(a+b)

# cumulative distribution function
plot(x,pbeta(x,10,15),type='l')
abline(v=(10/(10+15)))

# quantile function
plot(x,qbeta(x,10,15),type='l')
abline(h=(10/(10+15)))

# histogram of 1000 samples
hist(rbeta(1000,10,15),main=1000,probability=TRUE,breaks=40)  
lines(x,dbeta(x,10,15),col=2)

```


### Problem 3

Numerically transform a lognormal(meanlog=0,sdlog=0.5) through sin(x) using Monte Carlo simulation. Include histograms of the original and transformed distributions. Report the mean, median, and 95% CI for both distributions and indicate these values on the histograms. 

```{r}

x = rlnorm(1000, meanlog=0,sdlog=0.5)
y = sin(x)

hist(x,main="Original distribution",breaks=40)
abline(v=quantile(x,c(0.025,0.5,0.975)),lty=c(2,1,2),lwd=3,col="orange")
abline(v=mean(x),col="red",lwd=3,lty=3)
paste0("Mean = ", mean(x))
paste0("Median = ", median(x))
paste0("CI = ", quantile(x,c(0.025,0.975)))

hist(y,main="Transformed distribution",breaks=40)
abline(v=quantile(y,c(0.025,0.5,0.975)),lty=c(2,1,2),lwd=3,col="orange")
abline(v=mean(y),col="red",lwd=3,lty=3)
paste0("Mean = ", mean(y))
paste0("Median = ", median(y))
paste0("CI = ", quantile(y,c(0.025,0.975)))

```

### Monte Carlo simulation

```{r}
r = 2.1
r.sd = 0.2     ## standard deviation on r
K.sd = 1.0     ## standard deviation on K
NE = 1000      ## Ensemble size

n = matrix(n0,NE,NT)   # storage for all simulations
rE = rnorm(NE,r,r.sd)  # sample of r
KE = rnorm(NE,K,K.sd)  # sample of K
for(i in 1:NE){        # loop over samples
  for(t in 2:NT){      # for each sample, simulate throught time
    n[i,t] = n[i,t-1] + rE[i]*n[i,t-1]*(1-n[i,t-1]/KE[i])
  }
}

n.stats = apply(n,2,quantile,c(0.025,0.5,0.975))
```

### Problem 4

Plot histograms of the samples of r and K used for the simulation.

```{r}
hist(rE)
hist(KE)
```

### Problem 5 
Plot a sample of 10 different trajectories (through time) from your ensemble (on one graph).

```{r}

# add first trajectory (first row) to plot
plot(time,n[1,],ylim=c(0,14),type='l',
     bty='l',cex.lab=1.5,
     xlab="Time",ylab="Population Size")

# add next 9 trajectories
for (i in 2:10){
lines(time, n[i,], col=i)
}

```

### Problem 6 
Plot a histogram of your population forecast at time = 15.

```{r}

hist(n[,15], breaks=40, xlim=c(0,14))
```

### Problem 7

Plot the median trajectory through time. Use `ecoforecastR::ciEnvelope` to add a 95% CI (i.e. 2.5% to 97.5%) to the plot. This function need to take time-series for both the upper (yhi) and lower (ylo) intervals.

```{r}
plot(time, n.stats[2,],ylim=c(0,14),type='l',
     bty='l',cex.lab=1.5,
     xlab="Time",ylab="Population Size")
ecoforecastR::ciEnvelope(time, n.stats[3,], n.stats[1,], col="lightgreen")
lines(time, n.stats[2,], col="darkgreen", lwd=3)
```




###Extra Credit: Initial conditions
--------------------------------

The approach for simulating uncertainty in the initial conditions is very similar to the approach used for the parameter uncertainty.  As in Chapter 2, we'll assume that the initial condition is distributed as a lognormal to ensure that we never draw negative values. For this example we'll assume a standard deviation of 0.6 and an intrinsic growth rate of 0.3

```{r}
r = 0.3
n0.sd = 0.6
n0s = rlnorm(NE,log(n0),n0.sd)
n = matrix(n0s,NE,NT)
for(i in 1:NE){
  for(t in 2:NT){
    n[i,t] = n[i,t-1] + r*n[i,t-1]*(1-n[i,t-1]/K)
  }
}
```

### Problem 8

Plot the median & 95% interval.
```{r}
n.stats = apply(n,2,quantile,c(0.025,0.5,0.975))
plot(time, n.stats[2,],ylim=c(0,14),type='l',
     bty='l',cex.lab=1.5,
     xlab="Time",ylab="Population Size")
ecoforecastR::ciEnvelope(time, n.stats[3,], n.stats[1,], col="lightgreen")
lines(time, n.stats[2,], col="darkgreen", lwd=3)

```

### Problem 9

Repeat with r equal to 1.95, 2.05, and 2.8

```{r}
rvals <- c(1.95, 2.05, 2.8)
for (i in 1:3) {
r = rvals[i]
n0.sd = 0.6
n0s = rlnorm(NE,log(n0),n0.sd)
n = matrix(n0s,NE,NT)
for(i in 1:NE){
  for(t in 2:NT){
    n[i,t] = n[i,t-1] + r*n[i,t-1]*(1-n[i,t-1]/K)
  }
}
n.stats = apply(n,2,quantile,c(0.025,0.5,0.975))
plot(time, n.stats[2,],ylim=c(0,14),type='l',
     bty='l',cex.lab=1.5,
     xlab="Time",ylab="Population Size", main = paste0("R = ", r))
ecoforecastR::ciEnvelope(time, n.stats[3,], n.stats[1,], col="lightgreen")
lines(time, n.stats[2,], col="darkgreen", lwd=3)
}
```
