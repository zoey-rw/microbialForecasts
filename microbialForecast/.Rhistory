scenario = "full_uncertainty"
time_period = "2015-11_2018-01"
rank.name = keep_fg_names[37]
rank.name
rank.name = microbialForecast:::keep_fg_names[37]
rank.name
microbialForecast:::keep_fg_names
rank.name = microbialForecast:::keep_fg_names[12]
time_period = "2015-11_2018-01"
min.date = "20151101"
max.date = "20180101"
message("Beginning forecast loop for: ", rank.name)
cal.rank.df <- cal[[rank.name]]
val.rank.df <- val[[rank.name]]
rank.df <- rbind(cal.rank.df, val.rank.df)
# Prep validation data
model.inputs <- prepFunctionalData(rank.df = rank.df, min.prev = 3,
min.date = "20151101", max.date = "20200101",
full_timeseries = T)
model_output_list <- list()
message("Forecasting with model: ", model_name)
model_name = "all_covariates"
message("Forecasting with model: ", model_name)
# Filter model estimates for each plot abundance
plot_summary <- summaries$plot_est %>%
filter(time_period == !!time_period &
model_name == !!model_name &
species == !!rank.name)
# Get model outputs
f <- paste0("./data/model_outputs/functional_groups/", model_name, "/samples_", rank.name,"_", min.date, "_", max.date, ".rds")
read_in <- readRDS(f)
gelman.diag(read_in$samples)
param_samples <- as.data.frame(as.matrix(read_in$samples))
truth.plot.long <- model.dat <- read_in$metadata$model_data
plot_site_key <- model.dat %>%
select(siteID, plotID, dateID, date_num, plot_num, site_num) %>%
distinct()
site_list <- unique(plot_site_key$siteID)
# Use new model inputs for full date, site, and plot keys
new_plot_site_key <- model.inputs$truth.plot.long %>%
select(siteID, plotID, dateID, date_num, plot_num, site_num) %>%
distinct() %>%
filter(!siteID %in% plot_site_key$siteID)
new_site_list <- unique(new_plot_site_key$siteID)
# Forecast at both observed and unobserved sites
full_site_list <- c(site_list, new_site_list)
site_output_list <- list()
site_list
siteID <- site_list[[1]] #testing
siteID <- new_site_list[[1]] #testing
siteID <- site_list[[1]] #testing
message("SiteID: ", siteID)
newsite <- siteID %in% new_plot_site_key$siteID
plot_key <- if (newsite) new_plot_site_key else plot_site_key
plot_key <- plot_key %>% filter(siteID == !!siteID)
plot_list <- unique(plot_key$plotID)
plot_output_list <- list()
plotID <- plot_list[[1]] #testing
plot_list
message("PlotID: ", plotID)
#go for it!!!
hindcast.plot <- fg_fcast(plotID, model.inputs,
param_samples, group,
truth.plot.long,
Nmc = 5000,
plot_summary) %>% mutate(model_name = !!model_name,
time_period = !!time_period,
species = !!rank.name,
taxon = !!rank.name,
fcast_type = "Functional group")
tail(hindcast.plot)
hindcast.plot %>% filter(!is.na(hindcast.plot$truth))
head(truth.plot.long)
truth.plot.long %>% filter(!is.na(truth.plot.long$truth) & siteID=="BART")
truth.plot.long %>% filter(!is.na(truth.plot.long$truth) & siteID=="BART" & dateID > 201712)
truth.plot.long %>% filter(!is.na(truth.plot.long$truth) & siteID=="BART" & as.numeric(dateID) > 201712)
bart <- truth.plot.long %>% filter(!is.na(truth.plot.long$truth) & siteID=="BART")
table(bart$dateID)
library(reshape2) #melt()
library(googlesheets4) #read_sheet()
library(tidyverse)
library(MLmetrics) #F1_Score()
library(ConfusionTableR) #binary_class_cm()
library(ggradar)
library(fmsb) #radarchart()
library(ggradar2)
setwd("/projectnb2/talbot-lab-data/metabolic_models/aeng/")
# read in data
models_lit <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "models literature")
setwd("/projectnb2/talbot-lab-data/metabolic_models/aeng/")
# read in data
models_lit <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "models literature")
#cobra_sims <- read.csv("output_major_carbon_sources.csv")
cobra_sims <- read.csv("output_major_carbon_sources_M8.csv")
cobra_sims <- select(cobra_sims, -X0)
rownames(cobra_sims) <- cobra_sims[,1]
rownames(cobra_sims)[1] <- "neg_control"
cobra_sims <- cobra_sims[,-1]
# we want to rename the column names to be modelID's rather than the model (.xml)
modelID <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "modelID")
cobra_names <- modelID %>%
filter(model_name %in% names(cobra_sims))
cobra_sims_new <- cobra_sims %>%
rename_with(.cols = cobra_names$model_name, .fn = function(x) cobra_names$modelID[cobra_names$model_name %in% x])
# melting data frame to be long format
cobra_sims_long <- cobra_sims_new %>% rownames_to_column("c_source") %>%
pivot_longer(cols = 1:ncol(cobra_sims)+1)
neg_control <- cobra_sims_long %>% filter(c_source == "neg_control")  %>%
rename("neg_control"="value") %>% select(-c_source)
c_source <- cobra_sims_long %>% filter(c_source != "neg_control")
cobra_sims_long <- merge(neg_control, c_source)
colnames(cobra_sims_long)[1] <- "modelID"
cobra_sims_long <- cobra_sims_long %>% mutate_at(vars(value, neg_control), funs(round(., 3)))
cobra_sims_long$comp <- NA
for (row in 1:nrow(cobra_sims_long)) {
value <- cobra_sims_long[row,]$value
neg_control <- cobra_sims_long[row,]$neg_control
#print(value)
#print(neg_control)
if (value > neg_control) {
cobra_sims_long[row,]$comp = 1
} else if (value == neg_control) {
cobra_sims_long[row,]$comp = 0
} else if (value < neg_control) {
cobra_sims_long[row,]$comp = 0
}
}
# subset/filter data frame to contain columns of interest
models_lit <- models_lit %>% select(-c("Strain", "Culture medium", "Subgroup", "O2 tolerance", "Source"))
models_lit$index <- 1:nrow(models_lit)
# rename columns for metabolites to be coded as BiGG IDs to match the cobra_sims_long data frame using
bigg_id <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "bigg_id")
met_names <- bigg_id %>%
filter(compound %in% names(models_lit))
models_lit_partial <- models_lit %>% select(met_names$compound)
models_lit_partial$index <- 1:nrow(models_lit_partial)
models_ID <- subset(models_lit, select = c(modelID, index))
models_lit <- merge(models_ID, models_lit_partial)
models_lit <- models_lit[, -1] # dropping the index column
models_lit_new <- models_lit %>%
rename_with(.cols = met_names$compound, .fn = function(x) met_names$bigg_id[met_names$compound %in% x])
rownames(models_lit_new) <- models_lit_new[,1]
models_lit_new <- models_lit_new[,-1]
models_lit_new <- as.data.frame(t(models_lit_new))
# melt data frame to be long
models_lit_long <- models_lit_new %>% rownames_to_column("c_source") %>%
pivot_longer(cols = 1:ncol(models_lit_new)+1)
colnames(models_lit_long)[2] <- "modelID"
# re-coding the "values" to be in binary or NA, where Y = 1, N = 0, "No data = NA"
for (row in 1:nrow(models_lit_long)) {
if (is.na(models_lit_long[row,]$value)) {
} else if (models_lit_long[row,]$value == "Y") {
models_lit_long[row,]$value = "1"
} else if (models_lit_long[row,]$value == "N") {
models_lit_long[row,]$value = "0"
} else if (models_lit_long[row,]$value == "No data") {
models_lit_long[row,]$value = "NA"
}
}
models_lit_long$value <- as.numeric(models_lit_long$value)
cobra_sims_long$validation <- NA
for (row in 1:nrow(cobra_sims_long)) {
model_num <- cobra_sims_long[row,]$modelID
c_source <- cobra_sims_long[row,]$c_source
cobra_value <- cobra_sims_long[row,]$comp
lit_value <- models_lit_long[which(models_lit_long$c_source == c_source & models_lit_long$modelID == model_num),]$value
print(model_num)
print(c_source)
print(lit_value)
if (length(lit_value) != 0) {
if (!is.na(lit_value)) {
if (cobra_value == 1 & lit_value == 1) {
cobra_sims_long[row,]$validation = "TP"
} else if (cobra_value == 1 & lit_value == 0) {
cobra_sims_long[row,]$validation = "FP"
} else if (cobra_value == 0 & lit_value == 1) {
cobra_sims_long[row,]$validation = "FN"
} else if (cobra_value == 0 & lit_value == 0) {
cobra_sims_long[row,]$validation = "TN"
}
print(cobra_sims_long[row,]$validation)
}
}
}
c_source_list <- list("acgam_e", "algac__M_e", "cellb_e", "chitin_e", "chitos_e", "fru_e", "gal_e", "glc__D_e", "lcts_e", "lyx__L_e", "malt_e", "man_e", "pectin_e", "pyr_e", "raffin_e", "rib__D_e", "starch_e", "succ_e", "sucr_e", "tre_e", "xyl__D_e", "xylan4_e")
F1_c_source_list <- c()
for (met in c_source_list) {
c_source_df <- merge(models_lit_long[models_lit_long$c_source == met,] %>% select(modelID, c_source, obs = value),
cobra_sims_long[cobra_sims_long$c_source == met,] %>% select(modelID, c_source, pred = comp, validation))
# Remove missing observations
c_source_df <- c_source_df %>% filter(!is.na(obs))
# Convert to factors
c_source_df <- c_source_df %>% mutate(pred = factor(c_source_df$pred, levels=c("1","0")),
obs = factor(c_source_df$obs, levels=c("1","0")))
#confusion_results <- confusionMatrix(c_source_df$pred, c_source_df$obs, mode = "everything", positive="1")
# This includes the Caret function, but gives us a better output
mc_df <- ConfusionTableR::binary_class_cm(c_source_df$pred, c_source_df$obs,
mode="everything")
out <- cbind.data.frame(c_source = met, mc_df$record_level_cm)
print(met)
F1_c_source_list[[met]] <- out
# If we assign F1 to zero when precision and recall are both zero:
#https://datascience.stackexchange.com/questions/72074/can-the-f1-score-be-equal-to-zero
}
F1_c_source <- do.call(rbind, F1_c_source_list)
write.table(F1_c_source, "/projectnb/talbot-lab-data/metabolic_models/aeng/F1_c_source.csv", sep = ",")
models_list <- list("MP5ACTX8", "MP5ACTX9", "SP1PR4", "capsulatum", "Ellin345", "solibacter", "GAS232", "EB95", "AB60", "AB23", "aggregatus", "elongata", "MP5ACTX2", "rosea_T4", "methylaliphatogenes_K22", "roseus")
F1_model_list <- c()
for (mod in models_list) {
model_df <- merge(models_lit_long[models_lit_long$modelID == mod,] %>% select(modelID, c_source, obs = value),
cobra_sims_long[cobra_sims_long$modelID == mod,] %>% select(modelID, c_source, pred = comp, validation))
# Remove missing observations
model_df <- model_df %>% filter(!is.na(obs))
# Convert to factors
model_df <- model_df %>% mutate(pred = factor(model_df$pred, levels=c("1","0")),
obs = factor(model_df$obs, levels=c("1","0")))
#confusion_results <- confusionMatrix(c_source_df$pred, c_source_df$obs, mode = "everything", positive="1")
# This includes the Caret function, but gives us a better output
mc_df <- ConfusionTableR::binary_class_cm(model_df$pred, model_df$obs,
mode="everything")
out <- cbind.data.frame(modelID = mod, mc_df$record_level_cm)
print(met)
F1_model_list[[mod]] <- out
# If we assign F1 to zero when precision and recall are both zero:
#https://datascience.stackexchange.com/questions/72074/can-the-f1-score-be-equal-to-zero
}
F1_models <- do.call(rbind, F1_model_list)
write.table(F1_models, "/projectnb/talbot-lab-data/metabolic_models/aeng/F1_models.csv", sep = ",")
ggplot(cobra_sims_long, aes(c_source, modelID)) + geom_tile(aes(fill = validation), colour = "white") +
scale_fill_hue() +
#scale_fill_gradient(low = "blue", high = "red") +
xlab("Metabolite") +
ylab("Model") +
theme_bw() +
theme(axis.text.x = element_text(angle = 50, hjust = 1, vjust = 1))
df <- cobra_sims_long %>%
filter(!is.na(validation)) %>%
group_by(c_source, validation) %>%
mutate(n_val_group = length(validation)) %>% ungroup() %>%
group_by(c_source) %>%
mutate(frac = n_val_group / length(validation))
ggplot(df, aes(x = c_source, y = frac, fill = validation)) +
geom_col(position = "fill") + coord_flip() + theme_bw()
cobra_sims_long
cobra_sims_long$validation <- NA
for (row in 1:nrow(cobra_sims_long)) {
model_num <- cobra_sims_long[row,]$modelID
c_source <- cobra_sims_long[row,]$c_source
cobra_value <- cobra_sims_long[row,]$comp
lit_value <- models_lit_long[which(models_lit_long$c_source == c_source & models_lit_long$modelID == model_num),]$value
print(model_num)
print(c_source)
print(lit_value)
if (length(lit_value) != 0) {
if (!is.na(lit_value)) {
if (cobra_value == 1 & lit_value == 1) {
cobra_sims_long[row,]$validation = "TP"
} else if (cobra_value == 1 & lit_value == 0) {
cobra_sims_long[row,]$validation = "FP"
} else if (cobra_value == 0 & lit_value == 1) {
cobra_sims_long[row,]$validation = "FN"
} else if (cobra_value == 0 & lit_value == 0) {
cobra_sims_long[row,]$validation = "TN"
}
print(cobra_sims_long[row,]$validation)
}
}
}
cobra_sims_long
row
row = 1
model_num <- cobra_sims_long[row,]$modelID
c_source <- cobra_sims_long[row,]$c_source
cobra_value <- cobra_sims_long[row,]$comp
lit_value <- models_lit_long[which(models_lit_long$c_source == c_source & models_lit_long$modelID == model_num),]$value
print(model_num)
print(c_source)
print(lit_value)
models_lit_long
cobra_sims_long$validatio
for (row in 1:nrow(cobra_sims_long)) {
model_num <- cobra_sims_long[row,]$modelID
c_source <- cobra_sims_long[row,]$c_source
cobra_value <- cobra_sims_long[row,]$comp
lit_value <- models_lit_long[which(models_lit_long$c_source == c_source & models_lit_long$modelID == model_num),]$value
print(model_num)
print(c_source)
print(lit_value)
if (length(lit_value) != 0) {
if (!is.na(lit_value)) {
if (cobra_value == 1 & lit_value == 1) {
cobra_sims_long[row,]$validation = "TP"
} else if (cobra_value == 1 & lit_value == 0) {
cobra_sims_long[row,]$validation = "FP"
} else if (cobra_value == 0 & lit_value == 1) {
cobra_sims_long[row,]$validation = "FN"
} else if (cobra_value == 0 & lit_value == 0) {
cobra_sims_long[row,]$validation = "TN"
}
print(cobra_sims_long[row,]$validation)
}
}
}
cobra_sims <- read.csv("output_major_carbon_sources.csv")
cobra_sims <- select(cobra_sims, -X0)
rownames(cobra_sims) <- cobra_sims[,1]
rownames(cobra_sims)[1] <- "neg_control"
cobra_sims <- cobra_sims[,-1]
# we want to rename the column names to be modelID's rather than the model (.xml)
modelID <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "modelID")
cobra_names <- modelID %>%
filter(model_name %in% names(cobra_sims))
cobra_sims_new <- cobra_sims %>%
rename_with(.cols = cobra_names$model_name, .fn = function(x) cobra_names$modelID[cobra_names$model_name %in% x])
# melting data frame to be long format
cobra_sims_long <- cobra_sims_new %>% rownames_to_column("c_source") %>%
pivot_longer(cols = 1:ncol(cobra_sims)+1)
neg_control <- cobra_sims_long %>% filter(c_source == "neg_control")  %>%
rename("neg_control"="value") %>% select(-c_source)
c_source <- cobra_sims_long %>% filter(c_source != "neg_control")
cobra_sims_long <- merge(neg_control, c_source)
colnames(cobra_sims_long)[1] <- "modelID"
cobra_sims_long <- cobra_sims_long %>% mutate_at(vars(value, neg_control), funs(round(., 3)))
cobra_sims_long$comp <- NA
for (row in 1:nrow(cobra_sims_long)) {
value <- cobra_sims_long[row,]$value
neg_control <- cobra_sims_long[row,]$neg_control
#print(value)
#print(neg_control)
if (value > neg_control) {
cobra_sims_long[row,]$comp = 1
} else if (value == neg_control) {
cobra_sims_long[row,]$comp = 0
} else if (value < neg_control) {
cobra_sims_long[row,]$comp = 0
}
}
# subset/filter data frame to contain columns of interest
models_lit <- models_lit %>% select(-c("Strain", "Culture medium", "Subgroup", "O2 tolerance", "Source"))
models_lit$index <- 1:nrow(models_lit)
# rename columns for metabolites to be coded as BiGG IDs to match the cobra_sims_long data frame using
bigg_id <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "bigg_id")
met_names <- bigg_id %>%
filter(compound %in% names(models_lit))
models_lit_partial <- models_lit %>% select(met_names$compound)
models_lit_partial$index <- 1:nrow(models_lit_partial)
models_ID <- subset(models_lit, select = c(modelID, index))
models_lit <- merge(models_ID, models_lit_partial)
models_lit <- models_lit[, -1] # dropping the index column
models_lit_new <- models_lit %>%
rename_with(.cols = met_names$compound, .fn = function(x) met_names$bigg_id[met_names$compound %in% x])
rownames(models_lit_new) <- models_lit_new[,1]
models_lit_new <- models_lit_new[,-1]
models_lit_new <- as.data.frame(t(models_lit_new))
# melt data frame to be long
models_lit_long <- models_lit_new %>% rownames_to_column("c_source") %>%
pivot_longer(cols = 1:ncol(models_lit_new)+1)
colnames(models_lit_long)[2] <- "modelID"
# re-coding the "values" to be in binary or NA, where Y = 1, N = 0, "No data = NA"
for (row in 1:nrow(models_lit_long)) {
if (is.na(models_lit_long[row,]$value)) {
} else if (models_lit_long[row,]$value == "Y") {
models_lit_long[row,]$value = "1"
} else if (models_lit_long[row,]$value == "N") {
models_lit_long[row,]$value = "0"
} else if (models_lit_long[row,]$value == "No data") {
models_lit_long[row,]$value = "NA"
}
}
models_lit_long$value <- as.numeric(models_lit_long$value)
cobra_sims_long$validation <- NA
for (row in 1:nrow(cobra_sims_long)) {
model_num <- cobra_sims_long[row,]$modelID
c_source <- cobra_sims_long[row,]$c_source
cobra_value <- cobra_sims_long[row,]$comp
lit_value <- models_lit_long[which(models_lit_long$c_source == c_source & models_lit_long$modelID == model_num),]$value
print(model_num)
print(c_source)
print(lit_value)
if (length(lit_value) != 0) {
if (!is.na(lit_value)) {
if (cobra_value == 1 & lit_value == 1) {
cobra_sims_long[row,]$validation = "TP"
} else if (cobra_value == 1 & lit_value == 0) {
cobra_sims_long[row,]$validation = "FP"
} else if (cobra_value == 0 & lit_value == 1) {
cobra_sims_long[row,]$validation = "FN"
} else if (cobra_value == 0 & lit_value == 0) {
cobra_sims_long[row,]$validation = "TN"
}
print(cobra_sims_long[row,]$validation)
}
}
}
c_source_list <- list("acgam_e", "algac__M_e", "cellb_e", "chitin_e", "chitos_e", "fru_e", "gal_e", "glc__D_e", "lcts_e", "lyx__L_e", "malt_e", "man_e", "pectin_e", "pyr_e", "raffin_e", "rib__D_e", "starch_e", "succ_e", "sucr_e", "tre_e", "xyl__D_e", "xylan4_e")
F1_c_source_list <- c()
for (met in c_source_list) {
c_source_df <- merge(models_lit_long[models_lit_long$c_source == met,] %>% select(modelID, c_source, obs = value),
cobra_sims_long[cobra_sims_long$c_source == met,] %>% select(modelID, c_source, pred = comp, validation))
# Remove missing observations
c_source_df <- c_source_df %>% filter(!is.na(obs))
# Convert to factors
c_source_df <- c_source_df %>% mutate(pred = factor(c_source_df$pred, levels=c("1","0")),
obs = factor(c_source_df$obs, levels=c("1","0")))
#confusion_results <- confusionMatrix(c_source_df$pred, c_source_df$obs, mode = "everything", positive="1")
# This includes the Caret function, but gives us a better output
mc_df <- ConfusionTableR::binary_class_cm(c_source_df$pred, c_source_df$obs,
mode="everything")
out <- cbind.data.frame(c_source = met, mc_df$record_level_cm)
print(met)
F1_c_source_list[[met]] <- out
# If we assign F1 to zero when precision and recall are both zero:
#https://datascience.stackexchange.com/questions/72074/can-the-f1-score-be-equal-to-zero
}
F1_c_source <- do.call(rbind, F1_c_source_list)
models_list <- list("MP5ACTX8", "MP5ACTX9", "SP1PR4", "capsulatum", "Ellin345", "solibacter", "GAS232", "EB95", "AB60", "AB23", "aggregatus", "elongata", "MP5ACTX2", "rosea_T4", "methylaliphatogenes_K22", "roseus")
F1_model_list <- c()
for (mod in models_list) {
model_df <- merge(models_lit_long[models_lit_long$modelID == mod,] %>% select(modelID, c_source, obs = value),
cobra_sims_long[cobra_sims_long$modelID == mod,] %>% select(modelID, c_source, pred = comp, validation))
# Remove missing observations
model_df <- model_df %>% filter(!is.na(obs))
# Convert to factors
model_df <- model_df %>% mutate(pred = factor(model_df$pred, levels=c("1","0")),
obs = factor(model_df$obs, levels=c("1","0")))
#confusion_results <- confusionMatrix(c_source_df$pred, c_source_df$obs, mode = "everything", positive="1")
# This includes the Caret function, but gives us a better output
mc_df <- ConfusionTableR::binary_class_cm(model_df$pred, model_df$obs,
mode="everything")
out <- cbind.data.frame(modelID = mod, mc_df$record_level_cm)
print(met)
F1_model_list[[mod]] <- out
# If we assign F1 to zero when precision and recall are both zero:
#https://datascience.stackexchange.com/questions/72074/can-the-f1-score-be-equal-to-zero
}
F1_models <- do.call(rbind, F1_model_list)
write.table(F1_models, "/projectnb/talbot-lab-data/metabolic_models/aeng/F1_models.csv", sep = ",")
ggplot(cobra_sims_long, aes(c_source, modelID)) + geom_tile(aes(fill = validation), colour = "white") +
scale_fill_hue() +
#scale_fill_gradient(low = "blue", high = "red") +
xlab("Metabolite") +
ylab("Model") +
theme_bw() +
theme(axis.text.x = element_text(angle = 50, hjust = 1, vjust = 1))
df <- cobra_sims_long %>%
filter(!is.na(validation)) %>%
group_by(c_source, validation) %>%
mutate(n_val_group = length(validation)) %>% ungroup() %>%
group_by(c_source) %>%
mutate(frac = n_val_group / length(validation))
ggplot(df, aes(x = c_source, y = frac, fill = validation)) +
geom_col(position = "fill") + coord_flip() + theme_bw()
df <- cobra_sims_long %>%
filter(!is.na(validation)) %>%
group_by(modelID, validation) %>%
mutate(n_val_group = length(validation)) %>% ungroup() %>%
group_by(modelID) %>%
mutate(frac = n_val_group / length(validation))
ggplot(df, aes(x = modelID, y = frac, fill = validation)) +
geom_col(position = "fill") + coord_flip() + theme_bw()
modelID <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "modelID")
genomes <- modelID %>%
select(c("modelID", "genome size (bp)", "subgroup"))
colnames(genomes)[2] <- "genome"
models_validation <- merge(F1_models, genomes)
models_validation
stats <- models_validation %>% select(c("modelID", "F1", "Accuracy", "Specificity", "Sensitivity", "Precision"))
radarchart(df = (stats[stats$modelID == "AB23",])[,-1], axistype = 0, maxmin = F) # this did not work
#adding a row with the maximum and minimum values
library(fmsb)
install.packages("fmsb")
library(fmsb)
radarchart(df = (stats[stats$modelID == "AB23",])[,-1], axistype = 0, maxmin = F) # this did not work
(stats[stats$modelID == "AB23",])[,-1]
data <- as.data.frame(matrix( sample( 2:20 , 10 , replace=T) , ncol=10))
colnames(data) <- c("math" , "english" , "biology" , "music" , "R-coding", "data-viz" , "french" , "physic", "statistic", "sport" )
# To use the fmsb package, I have to add 2 lines to the dataframe: the max and min of each topic to show on the plot!
data <- rbind(rep(20,10) , rep(0,10) , data)
# Check your data, it has to look like this!
# head(data)
head(data)
radar_df = stats[stats$modelID == "AB23",][,-1]
radarchart(df = radar_df, axistype = 0, maxmin = F) # this did not work
radar_df
radar_df <- rbind(rep(1,5) , rep(0,5) , radar_df)
radarchart(df = radar_df, axistype = 0)
library(microbialForecast)
install.packages("/projectnb2/talbot-lab-data/zrwerbin/temporal_forecast/microbialForecast_0.1.0.tar.gz", repos = NULL, type ="source")
# Fit taxa one-by-one to evaluate convergence.
#install.packages("/projectnb2/talbot-lab-data/zrwerbin/temporal_forecast/microbialForecast_0.1.0.tar.gz", repos = NULL, type ="source")
source("/projectnb/talbot-lab-data/zrwerbin/temporal_forecast/source.R")
#Get arguments from the command line
argv <- commandArgs(TRUE)
# Check if the command line is not empty and convert values to numerical values
if (length(argv) > 0){
j <- as.numeric( argv[1] )
} else j = 1
# Create parameters to pass
grp_key <- cbind.data.frame(group = 1:10, rank.names = microbialForecast:::tax_names)
params <- stack(microbialForecast:::rank_spec_names) %>% select(species = values, rank.names = ind)
load("/projectnb/talbot-lab-data/zrwerbin/temporal_forecast/microbialForecast/R/sysdata.rda")
ls
ls()
usethis::use_data(cycl_only_key, all_covariates_key,
keep_fg_names, fg_names, tax_names, pretty_rank_names, pretty_names,
calibration_label,date_recode, N_cyclers, FG_kingdoms, rank_spec_names, internal = TRUE)
setwd("~/")
setwd("/projectnb/talbot-lab-data/zrwerbin/temporal_forecast/microbialForecast/R")
setwd("/projectnb/talbot-lab-data/zrwerbin/temporal_forecast/microbialForecast")
usethis::use_data(cycl_only_key, all_covariates_key,
keep_fg_names, fg_names, tax_names, pretty_rank_names, pretty_names,
calibration_label,date_recode, N_cyclers, FG_kingdoms, rank_spec_names, internal = TRUE)
