# Source script for Nimble models (w/ environmental covariates, & cyclical covariates only)
setwd("/projectnb/talbot-lab-data/zrwerbin/temporal_forecast/")
here::i_am("source.R")

# Pacman package loader is used throughout scripts
# if (!require("pacman")) install.packages("pacman")
# if (!require("microbialForecast"))

#install.packages("/projectnb2/talbot-lab-data/zrwerbin/temporal_forecast/microbialForecast_0.1.0.tar.gz", repos = NULL, type="source")

	suppressPackageStartupMessages(library(tidyverse, warn.conflicts = F))
	pacman::p_load(pacman, microbialForecast,
							 nimble, coda, lubridate, here,
							 doParallel, data.table)


	# Convert sin and cos effect sizes to a seasonal amplitude parameter
	sin_cos_to_seasonality <- function(sin, cos){
		min_max <- getMaxMin(sin, cos)
		amplitude <- sqrt(sin^2 + cos^2)
		out <- cbind.data.frame(max=min_max, amplitude=amplitude)
		return(out)
	}



	source("https://raw.githubusercontent.com/colinaverill/NEFI_microbe/master/NEFI_functions/rsq_1.1.r")


	predictive_loss = function(observed, predicted, predicted_sd){
		npred = length(predicted)
		predictive_variance = predicted_sd^2
		residual_variance = (predicted - observed)^2
		P = sum(predictive_variance, na.rm=T)/npred
		G = sum(residual_variance, na.rm=T)/npred
		total_PL = P+G
		data.frame(total_PL = total_PL, predictive_variance=P, residual_variance=G)

	}

	# observed = cal_test$truth
	# mean_predicted = cal_test$Mean
	# sd_predicted = cal_test$SD
	# type=c("RMSE","BIAS","MAE",
	# 			 "CRPS", "RSQ", "RSQ.1",
	# 			 "RMSE.norm",  "residual_variance", "predictive_variance", "total_PL")
	#
	# add_scoring_metrics(observed = cal_test$truth,
	# 										mean_predicted = cal_test$Mean,
	# 										sd_predicted = cal_test$SD)

	add_scoring_metrics = function(observed, mean_predicted, sd_predicted,
																 type=c("RMSE","BIAS","MAE",
																 			 "CRPS", "RSQ", "RSQ.1",
																 			 "RMSE.norm",  "residual_variance", "predictive_variance", "total_PL", "CRPS_truncated")){

		require(Metrics, scoringRules)

		if(sum(is.na(observed )) > 0){stop('Error: NAs in observed vector.' )}
		if(sum(is.na(mean_predicted)) > 0){stop('Error: NAs in predicted vector.')}

		out_df <- cbind.data.frame(observed,mean_predicted,sd_predicted) %>%
			summarise(CRPS = mean(
				crps_norm(observed, mean_predicted, sd_predicted)),
				CRPS_truncated = mean(
					crps(observed,
							 family = "tnorm",
							 location = mean_predicted,
							 scale = sd_predicted, lower = 0, upper = Inf)),
				RMSE = rmse(actual = observed, predicted = mean_predicted),
				RSQ.1 = 1 - (RMSE^2)/var(observed),
				RSQ.1.colin = rsq_1.1(observed, mean_predicted),
				predictive_loss(observed, mean_predicted, sd_predicted),
				RMSE = rmse(actual = observed, predicted = mean_predicted),
				BIAS = bias(actual = observed, predicted = mean_predicted),
				MAE = mae(actual = observed, predicted = mean_predicted),
				MAPE = mape(actual = observed, predicted = mean_predicted),
				RSQ = summary(lm(observed ~ mean_predicted))$r.squared,
				abundance = mean(observed, na.rm=T),
				RMSE.norm = RMSE / abundance) %>% select(!!type)

		return(out_df)
	}


	first = function(x) x %>% nest %>% ungroup %>% slice(1) %>% unnest(data)



	quick_get_rank_df = function(k = 1,
															 min.date = "20151101",
															 max.date = "20200101"){

		pacman::p_load(reshape2, parallel, nimble, coda, tidyverse)

		# Subset to one rank.
		rank.name <- microbialForecast:::tax_names[k]
	# Read in microbial abundances
	cal <- c(readRDS(here("data", "clean/cal_groupAbundances_16S_2021.rds")),
					 readRDS(here("data", "clean/cal_groupAbundances_ITS_2021.rds")))
	val <- c(readRDS(here("data", "clean/val_groupAbundances_16S_2021.rds")),
					 readRDS(here("data", "clean/val_groupAbundances_ITS_2021.rds")))

	cal.rank.df <- cal[[rank.name]]
	val.rank.df <- val[[rank.name]]
	rank.df <- rbind(cal.rank.df, val.rank.df)

	# Prep model inputs/outputs.
	print(paste0("Preparing model data for ", rank.name))

	# spec_names <- colnames(rank.df)[!colnames(rank.df) %in% c("siteID", "plotID", "dateID", "sampleID", "dates", "plot_date","other")]
	# rank.df_spec <- rank.df %>%
	# 	select("siteID", "plotID", "dateID", "sampleID", "dates", "plot_date", !!spec_names)
	# rank.df_spec$other <- 1-rank.df_spec[[s]]

	model.dat <- prepTaxonomicData(rank.df = rank.df,
																 min.prev = 3,
																 min.date = min.date,
																 max.date = max.date)
	return(model.dat)
	}


	calc_cv <- function(x) sd(x, na.rm = T) / mean(x, na.rm = T) * 100

