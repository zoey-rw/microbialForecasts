---
title: "model_predictions_figures"
output: html_document
date: '2022-06-30'
editor_options: 
  chunk_output_type: console
---

```{r}
library(reshape2) #melt()
library(googlesheets4) #read_sheet()
library(tidyverse)
library(MLmetrics) #F1_Score()
library(ConfusionTableR) #binary_class_cm()
library(ggradar)
library(fmsb) #radarchart()
library(ggradar2)
```

```{r}
setwd("/projectnb2/talbot-lab-data/metabolic_models/aeng/")

# read in data
models_lit <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "models literature")
#cobra_sims <- read.csv("output_major_carbon_sources.csv")
cobra_sims <- read.csv("output_major_carbon_sources_M8.csv")
```

Cleaning up simulation data frame
```{r}
cobra_sims <- select(cobra_sims, -X0)
rownames(cobra_sims) <- cobra_sims[,1]
rownames(cobra_sims)[1] <- "neg_control"
cobra_sims <- cobra_sims[,-1]

# we want to rename the column names to be modelID's rather than the model (.xml)
modelID <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "modelID")

cobra_names <- modelID %>%
  filter(model_name %in% names(cobra_sims))
cobra_sims_new <- cobra_sims %>%
  rename_with(.cols = cobra_names$model_name, .fn = function(x) cobra_names$modelID[cobra_names$model_name %in% x])

# renaming for M8 models
cobra_names <- modelID %>%
  filter(model_name_M8 %in% names(cobra_sims))
cobra_sims_new <- cobra_sims %>%
  rename_with(.cols = cobra_names$model_name_M8, .fn = function(x) cobra_names$modelID[cobra_names$model_name_M8 %in% x])
```

```{r}
# melting data frame to be long format
cobra_sims_long <- cobra_sims_new %>% rownames_to_column("c_source") %>%  
  pivot_longer(cols = 1:ncol(cobra_sims)+1)
neg_control <- cobra_sims_long %>% filter(c_source == "neg_control")  %>% 
  rename("neg_control"="value") %>% select(-c_source)
c_source <- cobra_sims_long %>% filter(c_source != "neg_control")
cobra_sims_long <- merge(neg_control, c_source)
colnames(cobra_sims_long)[1] <- "modelID"
```

Converting cobra simulation results into binary to indicate growth or no growth
```{r}
cobra_sims_long <- cobra_sims_long %>% mutate_at(vars(value, neg_control), funs(round(., 3)))

cobra_sims_long$comp <- NA

for (row in 1:nrow(cobra_sims_long)) {
  value <- cobra_sims_long[row,]$value
  neg_control <- cobra_sims_long[row,]$neg_control
  #print(value)
  #print(neg_control)
  
  if (value > neg_control) {
    cobra_sims_long[row,]$comp = 1
  } else if (value == neg_control) {
    cobra_sims_long[row,]$comp = 0
  } else if (value < neg_control) {
    cobra_sims_long[row,]$comp = 0
  }
}
```

Cleaning up models_lit (literature data for single C source growth)

```{r}
# subset/filter data frame to contain columns of interest
models_lit <- models_lit %>% select(-c("Strain", "Culture medium", "Subgroup", "O2 tolerance", "Source"))
models_lit$index <- 1:nrow(models_lit)
```

```{r}
# rename columns for metabolites to be coded as BiGG IDs to match the cobra_sims_long data frame using
bigg_id <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "bigg_id")

met_names <- bigg_id %>%
  filter(compound %in% names(models_lit))

models_lit_partial <- models_lit %>% select(met_names$compound)
models_lit_partial$index <- 1:nrow(models_lit_partial)
models_ID <- subset(models_lit, select = c(modelID, index))

models_lit <- merge(models_ID, models_lit_partial)
models_lit <- models_lit[, -1] # dropping the index column

models_lit_new <- models_lit %>%
  rename_with(.cols = met_names$compound, .fn = function(x) met_names$bigg_id[met_names$compound %in% x])

rownames(models_lit_new) <- models_lit_new[,1]
models_lit_new <- models_lit_new[,-1]
models_lit_new <- as.data.frame(t(models_lit_new))
```

```{r}
# melt data frame to be long
models_lit_long <- models_lit_new %>% rownames_to_column("c_source") %>% 
  pivot_longer(cols = 1:ncol(models_lit_new)+1)
colnames(models_lit_long)[2] <- "modelID"
```

```{r}
# re-coding the "values" to be in binary or NA, where Y = 1, N = 0, "No data = NA"
for (row in 1:nrow(models_lit_long)) {
  if (is.na(models_lit_long[row,]$value)) {
} else if (models_lit_long[row,]$value == "Y") {
  models_lit_long[row,]$value = "1"
} else if (models_lit_long[row,]$value == "N") {
  models_lit_long[row,]$value = "0"
} else if (models_lit_long[row,]$value == "No data") {
  models_lit_long[row,]$value = "NA"
}
}

models_lit_long$value <- as.numeric(models_lit_long$value)
```

Comparing the models_lit_long to cobra_sims_long and coding TP, TN, FP, FN

```{r}
cobra_sims_long$validation <- NA
for (row in 1:nrow(cobra_sims_long)) {
    model_num <- cobra_sims_long[row,]$modelID
    c_source <- cobra_sims_long[row,]$c_source
    cobra_value <- cobra_sims_long[row,]$comp
    lit_value <- models_lit_long[which(models_lit_long$c_source == c_source & models_lit_long$modelID == model_num),]$value
    
    print(model_num)
    print(c_source)
    print(lit_value)
    
    if (length(lit_value) != 0) {
    if (!is.na(lit_value)) {
    if (cobra_value == 1 & lit_value == 1) {
        cobra_sims_long[row,]$validation = "TP"
    } else if (cobra_value == 1 & lit_value == 0) {
        cobra_sims_long[row,]$validation = "FP"
    } else if (cobra_value == 0 & lit_value == 1) {
        cobra_sims_long[row,]$validation = "FN"
    } else if (cobra_value == 0 & lit_value == 0) {
        cobra_sims_long[row,]$validation = "TN"
  } 
    print(cobra_sims_long[row,]$validation) 
    }
  }
}
```

Calculating F1 scores for sugars

```{r}
c_source_list <- list("acgam_e", "algac__M_e", "cellb_e", "chitin_e", "chitos_e", "fru_e", "gal_e", "glc__D_e", "lcts_e", "lyx__L_e", "malt_e", "man_e", "pectin_e", "pyr_e", "raffin_e", "rib__D_e", "starch_e", "succ_e", "sucr_e", "tre_e", "xyl__D_e", "xylan4_e") 

F1_c_source_list <- c()
for (met in c_source_list) {
  
  c_source_df <- merge(models_lit_long[models_lit_long$c_source == met,] %>% select(modelID, c_source, obs = value), 
                       cobra_sims_long[cobra_sims_long$c_source == met,] %>% select(modelID, c_source, pred = comp, validation))
  # Remove missing observations
  c_source_df <- c_source_df %>% filter(!is.na(obs))
   
  # Convert to factors
    c_source_df <- c_source_df %>% mutate(pred = factor(c_source_df$pred, levels=c("1","0")),
                                          obs = factor(c_source_df$obs, levels=c("1","0")))
    
    #confusion_results <- confusionMatrix(c_source_df$pred, c_source_df$obs, mode = "everything", positive="1")
    # This includes the Caret function, but gives us a better output 
    mc_df <- ConfusionTableR::binary_class_cm(c_source_df$pred, c_source_df$obs,
                                         mode="everything")
    out <- cbind.data.frame(c_source = met, mc_df$record_level_cm)
    
  print(met)

  F1_c_source_list[[met]] <- out

  # If we assign F1 to zero when precision and recall are both zero:
  #https://datascience.stackexchange.com/questions/72074/can-the-f1-score-be-equal-to-zero
}

F1_c_source <- do.call(rbind, F1_c_source_list)

#write.table(F1_c_source, "/projectnb/talbot-lab-data/metabolic_models/aeng/F1_c_source.csv", sep = ",")
```

Calculating F1 score for models

```{r}
models_list <- list("MP5ACTX8", "MP5ACTX9", "SP1PR4", "capsulatum", "Ellin345", "solibacter", "GAS232", "EB95", "AB60", "AB23", "aggregatus", "elongata", "MP5ACTX2", "rosea_T4", "methylaliphatogenes_K22", "roseus")

F1_model_list <- c()
for (mod in models_list) {
  
  model_df <- merge(models_lit_long[models_lit_long$modelID == mod,] %>% select(modelID, c_source, obs = value), 
                       cobra_sims_long[cobra_sims_long$modelID == mod,] %>% select(modelID, c_source, pred = comp, validation))
  # Remove missing observations
  model_df <- model_df %>% filter(!is.na(obs))
   
  # Convert to factors
    model_df <- model_df %>% mutate(pred = factor(model_df$pred, levels=c("1","0")),
                                          obs = factor(model_df$obs, levels=c("1","0")))
    
    #confusion_results <- confusionMatrix(c_source_df$pred, c_source_df$obs, mode = "everything", positive="1")
    # This includes the Caret function, but gives us a better output 
    mc_df <- ConfusionTableR::binary_class_cm(model_df$pred, model_df$obs,
                                         mode="everything")
    out <- cbind.data.frame(modelID = mod, mc_df$record_level_cm)
    
  print(met)

  F1_model_list[[mod]] <- out

  # If we assign F1 to zero when precision and recall are both zero:
  #https://datascience.stackexchange.com/questions/72074/can-the-f1-score-be-equal-to-zero
}

F1_models <- do.call(rbind, F1_model_list)

#write.table(F1_models, "/projectnb/talbot-lab-data/metabolic_models/aeng/F1_models.csv", sep = ",")
```

## Plotting
Heat map showing TP, TN, FP, FN
```{r}
ggplot(cobra_sims_long, aes(c_source, modelID)) + geom_tile(aes(fill = validation), colour = "white") +
  scale_fill_hue() +
  #scale_fill_gradient(low = "blue", high = "red") +
  xlab("Metabolite") +
  ylab("Model") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 50, hjust = 1, vjust = 1))
```

Fractional bar plot showing validation results by C source
```{r}
df <- cobra_sims_long %>% 
    filter(!is.na(validation)) %>% 
    group_by(c_source, validation) %>%
    mutate(n_val_group = length(validation)) %>% ungroup() %>% 
    group_by(c_source) %>% 
    mutate(frac = n_val_group / length(validation))

ggplot(df, aes(x = c_source, y = frac, fill = validation)) +
    geom_col(position = "fill") + coord_flip() + theme_bw()
```

Fractional bar plot showing validation results by model
```{r}
df <- cobra_sims_long %>% 
    filter(!is.na(validation)) %>% 
    group_by(modelID, validation) %>%
    mutate(n_val_group = length(validation)) %>% ungroup() %>% 
    group_by(modelID) %>% 
    mutate(frac = n_val_group / length(validation))

ggplot(df, aes(x = modelID, y = frac, fill = validation)) +
    geom_col(position = "fill") + coord_flip() + theme_bw()
```

Radar plots for validation statistics
```{r}
modelID <- read_sheet("https://docs.google.com/spreadsheets/d/1YWAp-wdQWh9OHmw82w-2QuqsCYh3IgXh4QE17t7en0g/edit#gid=771669281", sheet = "modelID")

genomes <- modelID %>%
  select(c("modelID", "genome size (bp)", "subgroup"))
colnames(genomes)[2] <- "genome"

models_validation <- merge(F1_models, genomes)
```

```{r}
# subset data frame to contain data we want
# F1, accuracy, specificity, sensitivity, precision
stats <- models_validation %>% select(c("modelID", "F1", "Accuracy", "Specificity", "Sensitivity", "Precision"))

radar_df = stats[stats$modelID == "AB23",][,-1]

radar_df = stats[1:3,][,-1]

radar_df <- rbind(rep(1,5) , rep(0,5) , radar_df) # add rows for max and min (1 and 0 for all metrics - is that right?)
radarchart(df = radar_df, axistype = 0)


radarchart(df = radar_df, axistype = 0, maxmin = F) # this did not work


radarchart(df = (stats[stats$modelID == "AB23",])[,-1], axistype = 0, maxmin = F) # this did not work

#adding a row with the maximum and minimum values
max <- c("max", 1, 1, 1, 1, 1)
min <- c("min", 1, 1, 1, 1, 1)
maxmin <- as.data.frame(rbind(max,min))
colnames(maxmin) <- colnames(stats)
stats <- rbind(maxmin, stats)
rownames(stats) <- NULL
stats$index <- 1:nrow(stats)
stats1 <- as.data.frame(apply(stats[,2:7], 2, as.numeric))
stats_final <- merge(stats)

stats_final <- left_join(stats1, select(stats, c("modelID", "index")), by = "index")
# re arranging columns
stats_final <- stats_final %>% select(modelID, F1, Accuracy, Specificity, Sensitivity, Precision)

AB23 <- stats_final[stats_final$modelID == c("max", "min", "AB23"),]
AB23 <- AB23[,-1]
AB23 <- as.data.frame(sapply(AB23, as.numeric))

radarchart(AB23)
radarchart(stats_final[3,2:6], maxmin = F, axistype = 4)
```

```{r}
ggradar(
  stats_final[3,], 
  values.radar = c("0", "0.5", "1"),
  grid.min = 0, grid.mid = 0.5, grid.max = 1,
  group.point.size = 0,
  group.line.width = 1,
  fill = T
  )
```

```{r}
ggradar2(stats_final[3,2:6],
         grid.min = 0,
         grid.max = 1,
         polygonfill = TRUE, 
         plot.legend = FALSE)

stats_test <- stats_final[3:nrow(stats_final),]
AB23 <- stats_final[3:4, 2:6]
ggradar2(stats_final,
         grid.min = 0,
         grid.max = 1,
         polygonfill = TRUE, 
         plot.legend = T)
```

